<!DOCTYPE html>
<html lang="de">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Blutdruck-Tracker â€“ Plot</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    </head>
    <body class="min-h-screen bg-gray-100">
        <header class="bg-blue-600 text-white p-4 shadow-md">
            <h1 class="text-2xl font-bold text-center">Blutdruck-Tracker</h1>
            <nav class="flex justify-center items-center mt-2 space-x-8">
                <div class="flex space-x-4">
                    <a href="{{ url_for('index') }}" class="hover:underline">Home</a>
                    {% if current_user.is_authenticated %}
                    <a href="{{ url_for('plot') }}" class="hover:underline">Plot</a>
                    {% endif %}
                </div>
                <div class="flex space-x-4">
                    {% if current_user.is_authenticated %}
                    <form action="{{ url_for('logout') }}" method="GET">  <!-- GET reicht, da logout idempotent -->
                        <button type="submit" class="hover:underline">Logout</button>
                    </form>
                    {% else %}
                    <a href="{{ url_for('login') }}" class="hover:underline">Login</a>
                    <a href="{{ url_for('register') }}" class="hover:underline">Registrieren</a>
                    {% endif %}
                </div>
            </nav>
        </header>
        <main class="w-full max-w-5xl mx-auto mt-8 p-6 bg-white rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-4">Verlauf</h2>
            <div id="chart" class="w-full" style="height: 500px"></div>
        </main>
        <script>
        (function() {
            const logs = [
                {% for log in logs %}
                {
                    time: "{{ log.time.isoformat() }}",
                    sys: {{ log.sys }},
                    dia: {{ log.dia }},
                    pul: {{ log.pul }}
                }{% if not loop.last %},{% endif %}
                {% endfor %}
            ];

            const x = logs.map(l => l.time);
            const sys = logs.map(l => l.sys);
            const dia = logs.map(l => l.dia);
            const pul = logs.map(l => l.pul);

            const traces = [
                { name: 'Sys', x, y: sys, mode: 'markers', marker: { color: '#3b82f6', size: 8, opacity: 1.0 } },
                { name: 'Dia', x, y: dia, mode: 'markers', marker: { color: '#10b981', size: 8, opacity: 1.0 } },
                { name: 'Puls', x, y: pul, mode: 'markers', marker: { color: '#ef4444', size: 8, opacity: 1.0 }, yaxis: 'y2' }
            ];

            const layout = {
                margin: { t: 20, r: 40, b: 60, l: 60 },
                xaxis: { title: 'Zeit', type: 'date' },
                yaxis: { title: 'mmHg (Sys/Dia)' },
                yaxis2: { title: 'Puls (bpm)', overlaying: 'y', side: 'right' },
                legend: { orientation: 'h', x: 0, y: -0.2 }
            };

            const plotDiv = document.getElementById('chart');
            
            // Store original marker properties
            const originalColors = ['#3b82f6', '#10b981', '#ef4444'];
            const originalSizes = [8, 8, 8];
            const dataLength = sys.length;

            // Function to highlight related points from the same measurement
            function highlightRelatedPoints(pointIndex) {
                if (pointIndex === undefined || pointIndex === null || pointIndex < 0 || pointIndex >= dataLength) return;
                
                // Create arrays for marker sizes, opacities, and line colors for all traces
                // Keep marker.color as single values (not arrays) to preserve legend colors
                const markerSizes = [];
                const markerOpacities = [];
                const markerLineColors = [];
                const markerLineWidths = [];
                
                for (let i = 0; i < 3; i++) {
                    const sizes = new Array(dataLength).fill(originalSizes[i]);
                    const opacities = new Array(dataLength).fill(1.0); // Fully opaque
                    const lineColors = new Array(dataLength).fill('transparent');
                    const lineWidths = new Array(dataLength).fill(0);
                    
                    // Highlight the point at this index - use larger size and yellow border
                    sizes[pointIndex] = 16;
                    lineColors[pointIndex] = '#fbbf24'; // Yellow highlight border
                    lineWidths[pointIndex] = 3; // Thick border
                    
                    markerSizes.push(sizes);
                    markerOpacities.push(opacities);
                    markerLineColors.push(lineColors);
                    markerLineWidths.push(lineWidths);
                }
                
                // Save current ranges before restyling to prevent auto-adjustment
                const currentLayout = plotDiv.layout;
                const currentRanges = {
                    'xaxis.range': currentLayout.xaxis.range ? 
                        [currentLayout.xaxis.range[0], currentLayout.xaxis.range[1]] : null,
                    'yaxis.range': currentLayout.yaxis.range ? 
                        [currentLayout.yaxis.range[0], currentLayout.yaxis.range[1]] : null,
                    'yaxis2.range': currentLayout.yaxis2 && currentLayout.yaxis2.range ? 
                        [currentLayout.yaxis2.range[0], currentLayout.yaxis2.range[1]] : null
                };

                // Update all three traces using Plotly.restyle
                // Don't update marker.color to preserve legend colors
                Plotly.restyle(plotDiv, {
                    'marker.size': markerSizes,
                    'marker.opacity': markerOpacities,
                    'marker.line.color': markerLineColors,
                    'marker.line.width': markerLineWidths
                }, [0, 1, 2]).then(function() {
                    // Restore current ranges to prevent auto-scaling from larger markers
                    const updateLayout = {};
                    if (currentRanges['xaxis.range']) {
                        updateLayout['xaxis.range'] = currentRanges['xaxis.range'];
                    }
                    if (currentRanges['yaxis.range']) {
                        updateLayout['yaxis.range'] = currentRanges['yaxis.range'];
                    }
                    if (currentRanges['yaxis2.range']) {
                        updateLayout['yaxis2.range'] = currentRanges['yaxis2.range'];
                    }
                    // Also lock autorange if we have ranges to prevent auto-scaling
                    if (Object.keys(updateLayout).length > 0) {
                        updateLayout['xaxis.autorange'] = false;
                        updateLayout['yaxis.autorange'] = false;
                        if (currentRanges['yaxis2.range']) {
                            updateLayout['yaxis2.autorange'] = false;
                        }
                        isProgrammaticRelayout = true;
                        Plotly.relayout(plotDiv, updateLayout).then(function() {
                            isProgrammaticRelayout = false;
                        });
                    }
                });
            }

            // Reset all points to default state
            function resetAllPoints() {
                const markerSizes = [];
                const markerOpacities = [];
                const markerLineColors = [];
                const markerLineWidths = [];
                
                for (let i = 0; i < 3; i++) {
                    markerSizes.push(new Array(dataLength).fill(originalSizes[i]));
                    markerOpacities.push(new Array(dataLength).fill(1.0)); // Fully opaque
                    markerLineColors.push(new Array(dataLength).fill('transparent'));
                    markerLineWidths.push(new Array(dataLength).fill(0));
                }
                
                // Save current ranges before restyling to prevent auto-adjustment
                const currentLayout = plotDiv.layout;
                const currentRanges = {
                    'xaxis.range': currentLayout.xaxis.range ? 
                        [currentLayout.xaxis.range[0], currentLayout.xaxis.range[1]] : null,
                    'yaxis.range': currentLayout.yaxis.range ? 
                        [currentLayout.yaxis.range[0], currentLayout.yaxis.range[1]] : null,
                    'yaxis2.range': currentLayout.yaxis2 && currentLayout.yaxis2.range ? 
                        [currentLayout.yaxis2.range[0], currentLayout.yaxis2.range[1]] : null
                };

                // Don't update marker.color to preserve legend colors
                Plotly.restyle(plotDiv, {
                    'marker.size': markerSizes,
                    'marker.opacity': markerOpacities,
                    'marker.line.color': markerLineColors,
                    'marker.line.width': markerLineWidths
                }, [0, 1, 2]).then(function() {
                    // Restore current ranges to prevent auto-scaling from marker size changes
                    const updateLayout = {};
                    if (currentRanges['xaxis.range']) {
                        updateLayout['xaxis.range'] = currentRanges['xaxis.range'];
                    }
                    if (currentRanges['yaxis.range']) {
                        updateLayout['yaxis.range'] = currentRanges['yaxis.range'];
                    }
                    if (currentRanges['yaxis2.range']) {
                        updateLayout['yaxis2.range'] = currentRanges['yaxis2.range'];
                    }
                    // Also lock autorange if we have ranges to prevent auto-scaling
                    if (Object.keys(updateLayout).length > 0) {
                        updateLayout['xaxis.autorange'] = false;
                        updateLayout['yaxis.autorange'] = false;
                        if (currentRanges['yaxis2.range']) {
                            updateLayout['yaxis2.autorange'] = false;
                        }
                        isProgrammaticRelayout = true;
                        Plotly.relayout(plotDiv, updateLayout).then(function() {
                            isProgrammaticRelayout = false;
                        });
                    }
                });
            }

            // Store initial axis ranges to prevent auto-scaling
            let fixedRanges = null;
            let isProgrammaticRelayout = false; // Flag to prevent recursion

            // Create plot and set up event listeners after plot is ready
            Plotly.newPlot('chart', traces, layout, { displayModeBar: false, responsive: true })
                .then(function() {
                    // Get and lock the axis ranges after initial plot
                    const plotData = plotDiv.data;
                    const currentLayout = plotDiv.layout;
                    
                    fixedRanges = {
                        'xaxis.range': [currentLayout.xaxis.range[0], currentLayout.xaxis.range[1]],
                        'yaxis.range': [currentLayout.yaxis.range[0], currentLayout.yaxis.range[1]],
                        'yaxis2.range': currentLayout.yaxis2 ? [currentLayout.yaxis2.range[0], currentLayout.yaxis2.range[1]] : null
                    };

                    // Lock axes to prevent auto-scaling
                    isProgrammaticRelayout = true;
                    Plotly.relayout(plotDiv, {
                        'xaxis.autorange': false,
                        'yaxis.autorange': false,
                        'yaxis2.autorange': false
                    }).then(function() {
                        isProgrammaticRelayout = false;
                    });

                    // Update fixedRanges when user manually zooms or pans
                    plotDiv.on('plotly_relayout', function(eventData) {
                        // Ignore programmatic relayouts (from our code)
                        if (isProgrammaticRelayout) return;
                        
                        // Only update if autorange is false (user has zoomed in, not out)
                        const currentLayout = plotDiv.layout;
                        if (!currentLayout.xaxis.autorange && 
                            !currentLayout.yaxis.autorange && 
                            (!currentLayout.yaxis2 || !currentLayout.yaxis2.autorange)) {
                            // User has manually zoomed/panned - update fixed ranges to current view
                            if (currentLayout.xaxis.range && 
                                currentLayout.yaxis.range && 
                                (!currentLayout.yaxis2 || currentLayout.yaxis2.range)) {
                                fixedRanges = {
                                    'xaxis.range': [currentLayout.xaxis.range[0], currentLayout.xaxis.range[1]],
                                    'yaxis.range': [currentLayout.yaxis.range[0], currentLayout.yaxis.range[1]],
                                    'yaxis2.range': currentLayout.yaxis2 && currentLayout.yaxis2.range ? 
                                        [currentLayout.yaxis2.range[0], currentLayout.yaxis2.range[1]] : null
                                };
                            }
                        } else {
                            // User has zoomed out (autorange is true) - clear fixed ranges so we don't restore old zoom
                            fixedRanges = null;
                        }
                    });

                    // Event listeners for hover and click
                    plotDiv.on('plotly_hover', function(data) {
                        if (data.points && data.points.length > 0) {
                            const point = data.points[0];
                            const pointIndex = point.pointNumber;
                            highlightRelatedPoints(pointIndex);
                        }
                    });

                    plotDiv.on('plotly_unhover', function() {
                        resetAllPoints();
                    });

                    plotDiv.on('plotly_click', function(data) {
                        if (data.points && data.points.length > 0) {
                            const point = data.points[0];
                            const pointIndex = point.pointNumber;
                            highlightRelatedPoints(pointIndex);
                        } else {
                            // Clicked on empty area within the plot
                            resetAllPoints();
                        }
                    });

                    // Handle clicks outside the plot area
                    document.addEventListener('click', function(event) {
                        // Check if click is outside the plot div
                        if (!plotDiv.contains(event.target)) {
                            resetAllPoints();
                        }
                    });
                });
        })();
        </script>
    </body>
</html>


